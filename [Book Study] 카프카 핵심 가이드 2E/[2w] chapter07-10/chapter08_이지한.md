# chapter 08. '정확히 한 번' 의미 구조

## 정확히 한 번
* 멱등적 프로듀서 : 프로듀서 재시도로 인해 발생하는 중복 방지
* 트랜젝션 : 스트림 처리 애플리케이션에서 '정확히 한 번' 처리를 보장

## 멱등적 프로듀서

* 멱등적 : 동일 작업을 여러 번 실행해도 **한 번 실행한 것과 결과가 같은 서비스**
```sql
-- 멱등 X
1. UPDATE t SET x=x+1 where y=5
-- 멱등 O
2. UPDATE t SET x=18 where y=5
```
### 멱등적 프로듀서의 작동 원리

* 고유한 프로듀서 ID와 시퀀스 넘버를 가짐
* 브로커가 이전에 받은 적이 있는 메시지를 받게되면, 적절한 에러를 발생
  * 프로듀서에 로깅되고 지표에도 반영되지만, 예외가 발생한 것은 아니라 사용자에게 경고를 보내지는 않음
  * RequestMetrics 유형의 ErrorsPerSec 지표값에 기록됨

### 작동 실패 시, 멱등적 프로듀서 처리

1. 프로듀서 재시작
* 멱등적 프로듀서 기능이 켜져있다면, 프로듀서 초기화 과정에서 브로커로부터 프로듀서 ID를 생성받음
* 트랜젝션 기능이 꺼져있다면, 프로듀서 초기화할 때마다 완전히 새로운 ID가 생성됨
* 따라서 새 프로듀서가 기존 프로듀서가 이미 전송한 메시지를 다시 전송할 경우, 브로커는 중복이 발생한지 모름.

2. 브로커 장애
* 리더는 새 메시지가 쓰여질 때마다 인-메모리 프로듀서 상태에 최근 5개의 시퀀스 넘버를 업데이트함.
* 리더 브로커 장애로 팔로워가 리더가 된 시점에 메모리에 최근 5개의 시퀀스 넘버를 가지고 있음.
  * 따라서 아무 이슈나 지연 없이 새로운 메시지 유효성 검증 재개
* 예전 리더가 다시 돌아오면?
  * 스냅샷 파일에서 최신 상태를 읽어오고, 현재 리더로부터 복제한 레코드를 사용해서 프로듀서 상태를 업데이트함.

### 멱등적 프로듀서의 한계
* 프로듀서 내부 로직으로 인한 재시도(프로듀서, 네트워크, 브로커 에러)가 발생할 경우 생기는 중복만 방지함.
* producer.send() 두 번 호출하면 중복이 발생함.


### 멱등적 프로듀서 사용법
```
enable.idempotence=true
```
위의 기능을 활성화 하면 다음처럼 동작함.
* 프로듀서 ID를 받아오기 위해 프로듀서 시동 시 API 호출
* 레코드 배치에 프로듀서 ID와, 첫 메시지의 시퀀스 포함
* 레코드 배치의 시퀀스 넘버를 검증해서 메시지 중복을 방지
* 장애가 발생하더라도 파티션에 쓰여지는 메시지들의 순서는 보장됨.

## 트랜잭션

### 트랜잭션이 해결하는 문제

* 상황 가정
  * 원본 토픽으로부터 이벤트를 읽어서 처리 후, 결과를 다른 토픽에 쓴다.

1. 애플리케이션 크래시로 인한 재처리
* 결과를 다른 토픽에 썼는데, 원본 토픽 입력 오프셋이 커밋되기 전에 애플리케이션이 크래시 발생!
* 컨슈머 리밸런스가 발생하고, 컨슈머가 읽고있던 파티션들은 다른 컨슈머로 재할당 됨.
* 할당받은 컨슈머가 마지막 커밋 오프셋부터 레코드를 읽기 시작함.
* 중복 처리 발생.

2. 좀비 애플리케이션에 의해 발생하는 재처리
* 애플리케이션이 레코드 배치를 읽어온 직후 바로 연결이 끊어진 상황.
* 1번과 동일하게 새로운 컨슈머가 할당받아 처리 후
* 멈췄던 애플리케이션이 다시 살아남.
* 마지막으로 읽어왔던 레코드 배치를 처리하느라 중복 발생.
  * 새로 카프카를 폴링하거나, 하트비트로 자기가 죽었다는걸 판정받기 전까지 실행 가능.

### 트랜잭션은 어떻게 '정확히 한 번'을 보장하는가?
![image](https://github.com/room-of-coding/backend-deep-dive/assets/39042837/e26f921e-93d2-4f00-89e3-e72c38d40806)
* 트랜잭션적 프로듀서를 사용해야함.
* 일반 프로듀서와 트랜잭션적 프로듀서 차이점
  * transactional.id 설정
  * initTransactions() 호출해서 초기화
* transactional.id는 재시작 하더라도 값이 유지됨.
* 이미 존재하는 transactional.id 프로듀서가 initTransactions()을 다시 호출하면 이전에 쓰던 producer.id 값을 할당해줌.

* 좀비펜싱
  * 프로듀서가 초기화를 위해 initTransaction()을 호출하면 transactional.id에 에포크 값을 증가시킴.
  * 동일한 transactional.id를 가지더라도, 에포크 값이 낮은 프로듀서가 요청을 보낼 경우 FencedProducer 에러 발생

![image](https://github.com/room-of-coding/backend-deep-dive/assets/39042837/c430f29b-7c0e-45bd-b0fd-cc53cdf4ee2a)

* 컨슈머에 격리수준이 올바르게 설정되어 있지 않은 경우, 기대하는 '정확히 한 번' 보장이 이루어지지 않음.
* 컨슈머에 isolation.level 설정하기
  * read_committed
  * read_uncommitted (default)

### 트랜잭션으로 해결할 수 없는 문제들
